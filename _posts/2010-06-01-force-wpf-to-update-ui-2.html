---
layout: post
title: Force WPF to update UI
date: 2010-06-01 22:44:00.000000000 +03:00
categories:
- Design
- WPF
tags: []
status: publish
type: post
published: true
meta:
  blogger_blog: blog.robertiagar.com
  blogger_author: Robert Iagar
  blogger_db3b302d302965486336003593d4e4dd_permalink: '1173392044544740503'
author: 
---
<p>I’ve recently posted a Twitter Client to <a href="http://twitby.codeplex.com">codeplex.com</a> and I’ve been frustrated that I can’t seem to manually update when the tweet was posted. So I’ve started thinking a came up with this solution.</p>
<p> <a name="more"></a>
<p>First create a Model that is derived from INotifyPropertyChanged and create the specific members:    </p>
<p>public event PropertyChangedEventHandler PropertyChanged;</p>
<p>protected void OnPropertyChanged(string propertyName)    <br />{     <br />      if (PropertyChanged != null)     <br />            PropertyChanged(this, new PropertyChangedEventArgs(propertyName));     <br />}</p>
<p>Define your properties:  </p>
<p>private DateTime _timeAgo;     </p>
<p>public string TimeAgo     <br />{     <br />      get { return _timeAgo.ToRelativeTime(); //TweetSharp Extension }     <br />      set     <br />      {     <br />            _timeAgo = DateTime.Parse(value);     <br />            OnPropertyChanged(“TimeAgo”);     <br />      }     <br />}</p>
<p>Now define a System.Timers.Timer:</p>
<p>using System.Timers;    <br />private Timer _timer = new Timer(){ Interval = 30000 //30000 miliseconds = 30 seconds };     <br />private bool TimerFlag = true;</p>
<p>Modify your OnPropertyChanged method and add a new method to handle the Timer’s Elapsed event:</p>
<p>protected void OnPropertyChanged(string propertyName)    <br />{     <br />      if(TimerFlag)     <br />      {     <br />            _timer.Elapsed +=  new ElapsedEventHandler(_timer_Elapsed);     <br />            _timer.Start();              <br />            TimerFlag = false;     <br />      }     <br />      if (PropertyChanged != null)     <br />            PropertyChanged(this, new PropertyChangedEventArgs(propertyName));     <br />}     </p>
<p>private void _timer_Elapsed(object sender, ElapsedEventArgs e)     <br />{     <br />      OnPropertyChanged(“TimeAgo”);     <br />}</p>
<p>Now I’m not sure how effective is this way but it seems to do the job for me. This only works for this kind of a scenario, because once the Model returns the TimeAgo, WPF’s DataBinding System doesn’t know if the property is changing over time. To it, it’s just a string. In other scenario’s when you change the property WPF’s DataBinding System knows that because of the OnPropertyChanged in set.    </p>
<p>Simple, not sure if elegant but definitely works.</p>
<p>Can’t wait to hear your opinions on this.</p>
