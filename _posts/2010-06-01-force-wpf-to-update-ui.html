---
layout: post
title: Force WPF to update UI
date: 2010-06-01 20:44:14.000000000 +03:00
categories:
- Design
- WPF
tags:
- WPF
status: publish
type: post
published: true
meta:
  _wpas_done_fb: '1'
  _wpas_done_twitter: '1'
  tagazine-media: a:7:{s:7:"primary";s:0:"";s:6:"images";a:0:{}s:6:"videos";a:0:{}s:11:"image_count";s:1:"0";s:6:"author";s:8:"12668130";s:7:"blog_id";s:8:"12313015";s:9:"mod_stamp";s:19:"2010-06-03
    20:07:15";}
author: 
---
<p>I’ve recently posted a Twitter Client to <a href="http://twitby.codeplex.com">codeplex.com</a> and I’ve been frustrated that I can’t seem to manually update when the tweet was posted. So I’ve started thinking a came up with this solution.</p>
<p> <!--more-->
<p>First create a Model that is derived from INotifyPropertyChanged and create the specific members:    </p>
<p>public event PropertyChangedEventHandler PropertyChanged;</p>
<p>protected void OnPropertyChanged(string propertyName)    <br />{     <br />&#160;&#160;&#160;&#160;&#160; if (PropertyChanged != null)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; PropertyChanged(this, new PropertyChangedEventArgs(propertyName));     <br />}</p>
<p>Define your properties:&#160; </p>
<p>private DateTime _timeAgo;     </p>
<p>public string TimeAgo     <br />{     <br />&#160;&#160;&#160;&#160;&#160; get { return _timeAgo.ToRelativeTime(); //TweetSharp Extension }     <br />&#160;&#160;&#160;&#160;&#160; set     <br />&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; _timeAgo = DateTime.Parse(value);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; OnPropertyChanged(“TimeAgo”);     <br />&#160;&#160;&#160;&#160;&#160; }     <br />}</p>
<p>Now define a System.Timers.Timer:</p>
<p>using System.Timers;    <br />private Timer _timer = new Timer(){ Interval = 30000 //30000 miliseconds = 30 seconds };     <br />private bool TimerFlag = true;</p>
<p>Modify your OnPropertyChanged method and add a new method to handle the Timer’s Elapsed event:</p>
<p>protected void OnPropertyChanged(string propertyName)    <br />{     <br />&#160;&#160;&#160;&#160;&#160; if(TimerFlag)     <br />&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; _timer.Elapsed +=&#160; new ElapsedEventHandler(_timer_Elapsed);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; _timer.Start();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; TimerFlag = false;     <br />&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160; if (PropertyChanged != null)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; PropertyChanged(this, new PropertyChangedEventArgs(propertyName));     <br />}     </p>
<p>private void _timer_Elapsed(object sender, ElapsedEventArgs e)     <br />{     <br />&#160;&#160;&#160;&#160;&#160; OnPropertyChanged(“TimeAgo”);     <br />}</p>
<p>Now I’m not sure how effective is this way but it seems to do the job for me. This only works for this kind of a scenario, because once the Model returns the TimeAgo, WPF’s DataBinding System doesn’t know if the property is changing over time. To it, it’s just a string. In other scenario’s when you change the property WPF’s DataBinding System knows that because of the OnPropertyChanged in set.    </p>
<p>Simple, not sure if elegant but definitely works.</p>
<p>Can’t wait to hear your opinions on this.</p>
